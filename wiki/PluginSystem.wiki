dtEntity provides a plugin system for adding entity systems to the entity manager at run time.
By default, the dtEntity plugin manager looks in directory [working dir]/plugins for shared libraries/dlls. It opens all libraries in that directory and calls an entry function "CreatePluginFactories" if it exists. Example of an entry function inside a plugin: 

{{{

class DT_ENTITY_SIMULATION_EXPORT GroundClampingFactory 
   : public dtEntity::ComponentPluginFactory
{
public:

   virtual bool Create(dtEntity::EntityManager* em, dtEntity::EntitySystem*& es)
   {
      es = new dtEntitySimulation::GroundClampingSystem(*em);
      return true;
   }

   virtual std::string GetName() const
   {
      return "Ground Clamping";
   }

   virtual dtEntity::ComponentType GetType() const
   {
      return dtEntitySimulation::GroundClampingComponent::TYPE;
   }

   virtual std::string GetDescription() const
   {
      return "System for Ground Clamping";
   }
};

extern "C" DT_ENTITY_SIMULATION_EXPORT void CreatePluginFactories(std::list<dtEntity::ComponentPluginFactory*>& list)
{
   list.push_back(new GroundClampingFactory());
}
}}}

The plugin creates an instance of dtEntity::ComponentPluginFactory and pushes it into the offered list. The plugin manager will store the factory object and use it to instantiate the ground clamping system when one of this happens:
  * A map is loaded with an entity that contains a component of the type returned by GetType()
  * A scene is loaded that has an entry <entitysystem type="GroundClamping" />
  * EntityManager::CreateComponent is called with a component of the type returned by GetType()
  * A spawner is spawned containing a component of the given type